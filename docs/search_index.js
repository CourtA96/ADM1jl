var documenterSearchIndex = {"docs":
[{"location":"page3/#List-of-Functions","page":"List of Functions","title":"List of Functions","text":"","category":"section"},{"location":"page3/","page":"List of Functions","title":"List of Functions","text":"CurrentModule = ADM1jl","category":"page"},{"location":"page3/#Single-Reactor-Solvers","page":"List of Functions","title":"Single Reactor Solvers","text":"","category":"section"},{"location":"page3/","page":"List of Functions","title":"List of Functions","text":"ADM1sol","category":"page"},{"location":"page3/#ADM1jl.ADM1sol","page":"List of Functions","title":"ADM1jl.ADM1sol","text":"function ADM1sol(tspan::Tuple,u0::Vector,IV::Vector; <keyword arguments>)\n\nCompute the solution for the given timespan, tspan; initial condition, u0; and inflow vector IV.\n\nAlso return the time (in seconds) the solution took to compute. The difference between this function and ExampleSol is that this function reads in the parameter values from a .csv file.\n\nOptional Arguments\n\nalg = Rodas4P(): the ODE solver algorithm.\ntols = 1e-4: the absolute and relative tolerance of the solver method.\ntMax = 300.0: the maximum time (in seconds), that the function will run before timing out.\nsaveAt = []: specific times to save the solution. If given a number n, the solver will save the solution every n timesteps\n\nExamples\n\njulia> u0 = initialConditions();\n\njulia> IV = inflowvector_definition();\n\njulia> sol, tSol = ADM1sol((0.0,200.0),u0,IV);\n\njulia> sol\nretcode: Success\nInterpolation: specialized 3rd order \"free\" stiffness-aware interpolation\nt: 146-element Vector{Float64}:\n[...]\n\nu: 146-element Vector{Vector{Float64}}:\n[...]\n\njulia> tSol\n0.3854937\n\n\n\n\n\nfunction ADM1sol(tspan::Tuple,u0::Vector,IV::Vector{Vector{Float64}},IVtimes::Vector{Float64}; <keyword arguments>)\n\nCompute the solution with variable inflow for the given timespan, tspan; initial condition, u0; and variable inflow vector  IV where each entry in IV corresponds to the inflow vector at the corresponding entry in IVtimes\n\nAlso return the time (in seconds) the solution took to compute.\n\nOptional Arguments\n\nalg = Rodas4P(): the ODE solver algorithm.\ntols = 1e-4: the absolute and relative tolerance of the solver method.\ntMax = 300.0: the maximum time (in seconds), that the function will run before timing out.\nsaveAt = []: specific times to save the solution. If given a number n, the solver will save the solution every n timesteps\n\nExamples\n\njulia> u0 = initialConditions();\n\njulia> t = [i for i in 0.0:0.1:50.0];\n\njulia> IV_temp = inflowvector_definition();\n\njulia> IV = [IV_temp*(0.5*rand()+1.0) for i in 1:length(t)]\n\njulia> sol,tSol = ADM1sol((0.0,50.0),u0,IV,t);\n\njulia> sol\nretcode: Success\nInterpolation: specialized 3rd order \"free\" stiffness-aware interpolation\nt: 2011-element Vector{Float64}:\n[...]\n\nu: 2011-element Vector{Vector{Float64}}:\n[...]\n\njulia> tSol\n14.4643811\n\n\n\n\n\n","category":"function"},{"location":"page3/#Multiple-Reactor-Solvers","page":"List of Functions","title":"Multiple Reactor Solvers","text":"","category":"section"},{"location":"page3/","page":"List of Functions","title":"List of Functions","text":"MultiChamberSolution","category":"page"},{"location":"page3/#ADM1jl.MultiChamberSolution","page":"List of Functions","title":"ADM1jl.MultiChamberSolution","text":"function MultiChamberSolution(tspan::Tuple,u0::Tuple,IV::Vector,nChambers::Int64; <keyword arguments>)\n\nCompute the solution for a system of nChambers connected CSTRs with u0 initial conditions. The  inflow of the first CSTR is given by IV, the outflow of the first CSTR becomes the inflow of second CSTR  and so on.\n\nThis function reads in the parameter values from a .csv file. The names of the .csv files that contain the parameter values should be \"modelparameters.csv\", \"modelparameters2.csv\",  \"model_parameters3.csv\", ... and so on.\n\nArguments\n\nalg = Rodas4P(): the ODE solver algorithm.\ntols = 1e-4: the absolute and relative tolerance of the solver method.\ntMax = 300.0: the maximum time (in seconds), that the function will run before timing out.\nsaveAt = []: specific times to save the solution. If given a number n, the solver will save the solution every n timesteps\n\nExamples\n\njulia> u0 = initialConditions();\n\njulia> IV = inflowvector_definition();\n\njulia> sols = MultiChamberSolution((0.0,200.0),(u0,u0,u0),IV,3);\nFinished Chamber 1\nFinished Chamber 2\nFinished Chamber 3\n\njulia> sols[1]\nretcode: Success\nInterpolation: specialized 3rd order \"free\" stiffness-aware interpolation\nt: 115-element Vector{Float64}:\n[...]\n\nu: 115-element Vector{Vector{Float64}}:\n[...]\n\njulia> sols[2]\nretcode: Success\nInterpolation: specialized 3rd order \"free\" stiffness-aware interpolation\nt: 115-element Vector{Float64}:\n[...]\n\nu: 115-element Vector{Vector{Float64}}:\n[...]\n\njulia> sols[3]\nretcode: Success\nInterpolation: specialized 3rd order \"free\" stiffness-aware interpolation\nt: 115-element Vector{Float64}:\n[...]\n\nu: 115-element Vector{Vector{Float64}}:\n[...]\n\n\n\n\n\nfunction MultiChamberSolution(tspan::Tuple,u0::Tuple,IV::Vector{Vector{Float64}},IVtimes::Vector{Float64},nChambers::Int64;<keyword arguments>)\n\nCompute the solution for a system of nChambers connected CSTRs with u0 initial conditions. The  inflow of the first CSTR is given by variable inflow vector IV where each entry in IV corresponds to the inflow vector at the corresponding entry in IVtimes, the outflow of the first CSTR becomes the inflow of second CSTR  and so on.\n\nThis function reads in the parameter values from a .csv file. The names of the .csv files that contain the parameter values should be \"modelparameters.csv\", \"modelparameters2.csv\",  \"model_parameters3.csv\", ... and so on.\n\nArguments\n\nalg = Rodas4P(): the ODE solver algorithm.\ntols = 1e-4: the absolute and relative tolerance of the solver method.\ntMax = 300.0: the maximum time (in seconds), that the function will run before timing out.\nsaveAt = []: specific times to save the solution. If given a number n, the solver will save the solution every n timesteps\n\nExamples\n\njulia> u0 = initialConditions();\n\njulia> t = [i for i in 0.0:0.1:50.0];\n\njulia> IV_temp = inflowvector_definition();\n\njulia> IV = [IV_temp*(0.5*rand()+1.0) for i in 1:length(t)];\n\njulia> sols = MultiChamberSolution((0.0,50.0),(u0,u0,u0),IV,t,3);\nFinished Chamber 1\nFinished Chamber 2\nFinished Chamber 3\n\njulia> sols[1]\nretcode: Success\nInterpolation: specialized 3rd order \"free\" stiffness-aware interpolation\nt: 115-element Vector{Float64}:\n[...]\n\nu: 115-element Vector{Vector{Float64}}:\n[...]\n\njulia> sols[2]\nretcode: Success\nInterpolation: specialized 3rd order \"free\" stiffness-aware interpolation\nt: 115-element Vector{Float64}:\n[...]\n\nu: 115-element Vector{Vector{Float64}}:\n[...]\n\njulia> sols[3]\nretcode: Success\nInterpolation: specialized 3rd order \"free\" stiffness-aware interpolation\nt: 115-element Vector{Float64}:\n[...]\n\nu: 115-element Vector{Vector{Float64}}:\n[...]\n\n\n\n\n\n","category":"function"},{"location":"page3/#Parameter-Definitions","page":"List of Functions","title":"Parameter Definitions","text":"","category":"section"},{"location":"page3/","page":"List of Functions","title":"List of Functions","text":"initialConditions","category":"page"},{"location":"page3/#ADM1jl.initialConditions","page":"List of Functions","title":"ADM1jl.initialConditions","text":"  initialConditions()\n\nReturns the default initial conditions as a Vector{Float64} of length 35.\n\nExamples\n\njulia> initialConditions()\n35-element Vector{Float64}:\n 0.012\n 0.0053\n ⋮\n 1.63\n 0.014\n\n\n\n\n\n","category":"function"},{"location":"page3/","page":"List of Functions","title":"List of Functions","text":"inflowvector_definition","category":"page"},{"location":"page3/#ADM1jl.inflowvector_definition","page":"List of Functions","title":"ADM1jl.inflowvector_definition","text":"  inflowvector_definition()\n\nReturns the default inflow vector as a Vector{Float64} of length 35.\n\nExamples\n\njulia> inflowvector_definition()\n35-element Vector{Float64}:\n 0.01\n 0.001\n 0.001\n 0.001\n ⋮\n 0.02\n 0.0\n 0.0\n 0.0\n\n\n\n\n\n","category":"function"},{"location":"page3/#Plotting","page":"List of Functions","title":"Plotting","text":"","category":"section"},{"location":"page3/","page":"List of Functions","title":"List of Functions","text":"plotSols","category":"page"},{"location":"page3/#ADM1jl.plotSols","page":"List of Functions","title":"ADM1jl.plotSols","text":"plotSols(sol;<keyword arguments>)\n\nPlot the solutions returned by ADM1sol. The plots are split between two figures and are  displayed by default. However, due to an error in Julia's Plots package, the plot's windows  may overwrite eachother in some circumstances. If this occurs, use the keyword arguments  to view both plots manually.\n\nArguments\n\nsol::Vector: ODESolution returned by ADM1 sol\n\nOptional Arguments\n\ntitleText = \"Plot of Solutions\": The title of the plots\ndisplayPlots = true: Boolean to display the plots or not.\nsavePNG = false: Boolean to save pngs of the plots to the working directory as titleText(1 of 2).png and titleText(2 of 2).png\nreturnPlots = false: Boolean to return the plots as a tuple so they can be displayed manually\n\nExamples\n\njulia> u0 = initialConditions();\n\njulia> IV = inflowvector_definition();\n\njulia> sol, tSol = ADM1sol((0.0,200.0),u0,IV); # compute the solution\n\njulia> plotSols(sol); # display the plots\n\njulia> u0 = initialConditions();\n\njulia> IV = inflowvector_definition();\n\njulia> sol, tSol = ADM1sol((0.0,200.0),u0,IV); # compute the solution\n\njulia> plt1,plt2 = plotSols(sol,displayPlots=false,returnPlots=true); # return the plots\n\njulia> display(plt1); # display the first plot\n\njulia> display(plt2); # display the second plot\n\n\n\n\n\n","category":"function"},{"location":"page3/#Functions-used-by-solvers","page":"List of Functions","title":"Functions used by solvers","text":"","category":"section"},{"location":"page3/","page":"List of Functions","title":"List of Functions","text":"pressureOfGasses","category":"page"},{"location":"page3/#ADM1jl.pressureOfGasses","page":"List of Functions","title":"ADM1jl.pressureOfGasses","text":"pressureOfGasses(sx,php,rp)\n\nCompute the pressures of the gasses.\n\nArguments\n\nsx::Vector: the state vector.\nphp::Vector: the physicochemical parameters.\nrp::Vector: the reactor parameters.\n\nExamples\n\njulia> u0 = initialConditions();\n\njulia> rp = reactorParameterDefinition();\n\njulia> php = physiochemicalParameterDefinition(rp);\n\njulia> pressureOfGasses(u0,php,rp)\n5-element Vector{Float64}:\n    1.6333471490625e-5\n    0.6525381992578124\n    0.35869584449999997\n    1.0669181223042932\n    2695.9061152146637\n\n\n\n\n\n","category":"function"},{"location":"page3/","page":"List of Functions","title":"List of Functions","text":"monod","category":"page"},{"location":"page3/#ADM1jl.monod","page":"List of Functions","title":"ADM1jl.monod","text":"monod(u, k)\n\nCompute the monod function u/(u+k) where u is the state varible and k is the half-saturation concentration.\n\nIf u <= 0 return 0.\n\nExamples\n\njulia> monod(3.0,2.0) # when u is non-zero positive\n0.6\n\njulia> monod(-3.0,2.0) # when u is negative\n0\n\n\n\n\n\n","category":"function"},{"location":"page3/","page":"List of Functions","title":"List of Functions","text":"RHSfun","category":"page"},{"location":"page3/#ADM1jl.RHSfun","page":"List of Functions","title":"ADM1jl.RHSfun","text":"RHSfun(du,u,p,t)\n\nReturn the right-hand side of the system of ODEs, this is an in-place function.\n\nArguments\n\ndu::Vector: the rate change of the state vector (required since the function is defined in-place).\nu::Vector: the state vector.\np::Vector: all of the model parameters.\nt: the timestep, usually a Float64.\n\n\n\n\n\n","category":"function"},{"location":"page3/","page":"List of Functions","title":"List of Functions","text":"RHSfunInflowVaried","category":"page"},{"location":"page3/#ADM1jl.RHSfunInflowVaried","page":"List of Functions","title":"ADM1jl.RHSfunInflowVaried","text":"RHSfunInflowVaried(du,u,p,t)\n\nReturn the right-hand side of the system of ODEs, this is an in-place function.\n\nArguments\n\ndu::Vector: the rate change of the state vector (required since the function is defined in-place).\nu::Vector: the state vector.\np::Vector: all of the model parameters.\nt: the timestep, usually a Float64.\n\n\n\n\n\n","category":"function"},{"location":"page3/#Matrix-Definition","page":"List of Functions","title":"Matrix Definition","text":"","category":"section"},{"location":"page3/","page":"List of Functions","title":"List of Functions","text":"transportmatrix_definition","category":"page"},{"location":"page3/#ADM1jl.transportmatrix_definition","page":"List of Functions","title":"ADM1jl.transportmatrix_definition","text":"transportmatrix_definition(rp,pressures)\n\nTransport matrix\n\n```\n\n\n\n\n\n","category":"function"},{"location":"page3/","page":"List of Functions","title":"List of Functions","text":"reactionrates","category":"page"},{"location":"page3/#ADM1jl.reactionrates","page":"List of Functions","title":"ADM1jl.reactionrates","text":"reactionrates(bp,rp,php,pressures,sx,NREAC::Int)\n\nCompute and return the vector of reaction rates.\n\nArguments\n\nbp::Vector: the biochemical parameters.\nrp::Vector: the reactor parameters.\nphp::Vector: the physiochemical parameters.\npressures::Vector: the gas pressures.\nsx::Vector: the state vector.\nNREAC::Integer: the number of reaction rates.\n\nExamples\n\njulia> u0 = initialConditions();\n\njulia> bp = biochemicalparameter_definition();\n\njulia> rp = reactorParameterDefinition();\n\njulia> php = physiochemicalParameterDefinition(rp);\n\njulia> pressures = pressureOfGasses(u0,php,rp);\n\njulia> NREAC = 29;\n\njulia> reactionrates(bp,rp,php,pressures,u0,NREAC)\n29-element Vector{Real}:\n 0.155\n 0.28\n 1.0\n 0.29000000000000004\n 0.2950855111452082\n ⋮\n 0.0\n 7.402547081085608e-6\n 1.295220255437568\n 0.052518812965057435\n\n\n\n\n\n","category":"function"},{"location":"page3/","page":"List of Functions","title":"List of Functions","text":"petersenmatrixtranspose_definition","category":"page"},{"location":"page3/#ADM1jl.petersenmatrixtranspose_definition","page":"List of Functions","title":"ADM1jl.petersenmatrixtranspose_definition","text":"petersenmatrixtranspose_definition(rp,bp,sp,cc)\n\nTranspose of the Petersen matrix\n\n```\n\n\n\n\n\n","category":"function"},{"location":"page3/#Other-Functions","page":"List of Functions","title":"Other Functions","text":"","category":"section"},{"location":"page3/","page":"List of Functions","title":"List of Functions","text":"individualSolutions","category":"page"},{"location":"page3/#ADM1jl.individualSolutions","page":"List of Functions","title":"ADM1jl.individualSolutions","text":"individualSolutions(sol)\n\nRearranges the ODESolution returned by ADM1sol into  a 1D array containing  vectors of each solution over time.\n\ni.e. A[i] is a vector containing the values of the ith solution for all times.\n\nSo, if we say t is a vector containing the timesteps, then    plot(t,A[i]) will plot the ith solution vs time.\n\nArguments\n\nsol::Vector: ODESolution returned by ADM1 sol\n\nExamples\n\n```juia-repl julia> u0 = initialConditions();\n\njulia> IV = inflowvector_definition();\n\njulia> sol, tSol = ADM1sol((0.0,200.0),u0,IV); # compute the solution\n\njulia> indSols = individualSolutions(sol); 35-element Vector{Vector{Float64}}:  [0.012, 0.011999986305998722, 0.011999977102201841, 0.01199997267285494, 0.011999969386113186, 0.011999967149464337, 0.011999965091000644, 0.011999963258166062, 0.01199996178749697, 0.011999961662742068  …  0.01195750330094027, 0.011957024281388772, 0.01195654102848209, 0.011955980109704207, 0.011955371939386264, 0.011955036272014314, 0.011954879037458292, 0.011954836213455822, 0.011954830158706282, 0.011954829810563401]  [0.0053, 0.005299528080754454, 0.005299211849244109, 0.005299059933102669, 0.005298947319276687, 0.005298870740171685, 0.005298800301401363, 0.005298737615364131, 0.005298687337685513, 0.005298683073531872  …  0.00531290262808903, 0.005313145376836529, 0.005313458937485294, 0.00531386295705003, 0.0053143158605383585, 0.0053145727297110815, 0.005314697865111298, 0.00531473416356305, 0.0053147398286552405, 0.0053147401832121036]  ⋮  [1.63, 1.6300010043803432, 1.630003893522008, 1.6300064891566448, 1.6300090584027846, 1.630011157417349, 1.630013359837308, 1.6300155516628245, 1.6300174749013072, 1.6300176449752604  …  1.6258740229661408, 1.6256583127128807, 1.6256250660754588, 1.625621749084325, 1.625620443499663, 1.6256197935003422, 1.6256194976733636, 1.6256194164919724, 1.6256194045086088, 1.6256194037384155]  [0.014, 0.013987846051651676, 0.01395723325778608, 0.013936637777305555, 0.013919032066060481, 0.013905958298756526, 0.01389316476641871, 0.013881173393149072, 0.013871152739877324, 0.013870287064082722  …  0.01414633009687048, 0.014149764848711631, 0.01415028486767014, 0.014150328062007254, 0.01415033918241631, 0.014150344102072282, 0.014150346161797715, 0.014150346675181056, 0.014150346741486993, 0.014150346745679485]\n\njulia> indSols[1] # Solution vector for the first state variable (S_su)  115-element Vector{Float64}:  0.012  0.011999986305998722  ⋮  0.011954830158706282  0.011954829810563401  ```\n\n\n\n\n\n","category":"function"},{"location":"#Documentation-for-ADM1code.jl","page":"Home","title":"Documentation for ADM1code.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is documentation for the Julia implementation of ADM1 written by Courtney Allen (University of Guelph) and Alexandra Mazanko (University of Guelph).","category":"page"},{"location":"","page":"Home","title":"Home","text":"This code has been used in the following paper:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Allen C, Mazanko A, Abdehagh N, Eberl HJ. \"A New ODE-Based Julia Implementation of the Anaerobic Digestion Model No. 1 Greatly Outperforms Existing DAE-Based Java and Python Implementations.\" Processes. 2023; 11(7):1899. https://doi.org/10.3390/pr11071899","category":"page"},{"location":"#Table-of-Contents","page":"Home","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"page2.md\",\"page3.md\"]\r\nDepth = 3","category":"page"},{"location":"page2/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"To solve ADM1 for a single tank reactor, just run ADM1sol. For multiple tanks running in parallel, use multichamberSolution","category":"page"},{"location":"page2/#Installation","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"To install ADM1jl open the Julia REPL and run the following:","category":"page"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"julia> using Pkg\r\njulia> Pkg.add(url=\"https://github.com/CourtA96/ADM1jl\")","category":"page"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"OR enter the Pkg REPL by pressing ] and running:","category":"page"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"add https://github.com/CourtA96/ADM1jl","category":"page"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"Then, to use the package, run","category":"page"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"julia> using ADM1jl","category":"page"},{"location":"page2/#Basic-Usage","page":"Getting started","title":"Basic Usage","text":"","category":"section"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"Before beginning, make sure that the file model_parameters.csv is saved in your working directory. model_parameters.csv can be found on the github here. ","category":"page"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"ADM1sol takes the timespan, initial conditions, and inflow vector as inputs. The timespan is length 2 and type Tuple{Float64}. It specifies how the initial and final times of the simulation. The initial conditions and inflow vector both have type Vector{Float64} and length 35. To test this out, run the following code:","category":"page"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"using ADM1jl\r\n\r\nu0 = initialConditions(); # assigns the default initial conditions to u0\r\n\r\nIV = inflowvector_definition(); # assigns the default inflow vector to IV\r\n\r\ntspan = (0.0,200.0); # the solution will be computed from t=0.0 to t=200.0\r\n\r\nsol, tSol = ADM1sol(tspan,u0,IV); # computes the solution  and saves it to sol, the time to solve is saved to tSol\r\n\r\nsol # the solution has two fields: t contains the timesteps and u contains the solution at each timestep\r\n\r\ntSol # this is the time ExampleSol took to solve the system","category":"page"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"To save solutions at specific times, use the saveAt keyword argument. It takes either a vector of times to stop, or a number n that tells the solver to save solution every n timesteps. For example:","category":"page"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"using ADM1jl\r\n\r\nu0 = initialConditions(); # assigns the default initial conditions to u0\r\n\r\nIV = inflowvector_definition(); # assigns the default inflow vector to IV\r\n\r\ntspan = (0.0,200.0); # the solution will be computed from t=0.0 to t=200.0\r\n\r\nsol2, tSol2 = ADM1sol(tspan,u0,IV,saveAt=[10.0,15.0,50.0,100.0,150.0,200.0]); # save the solution at 10 days, 15 days, 50 days and so on.\r\n\r\nsol3, tSol3 = ADM1sol(tspan,u0,IV,saveAt=5.0); # save the solution every 5 days","category":"page"},{"location":"page2/#Modifying-Parameters","page":"Getting started","title":"Modifying Parameters","text":"","category":"section"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"To change the system parameters, such as T_base or P_atm, just open the file model_parameters.csv in your working directory (model_parameters.csv can be found here). Edit whichever entries are necessary, save, and exit. Running ADM1sol again will solve the system with the updated parameters.","category":"page"},{"location":"page2/#Specifying-Alorithms","page":"Getting started","title":"Specifying Alorithms","text":"","category":"section"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"By default, ADM1sol solves the system using the Rodas4P algorithm given in the DifferentialEquations package (documentation for DifferentialEquations available here). To use a different algorithm, install the DifferentialEquations package and follow the example below:","category":"page"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"using DifferentialEquations\r\n\r\nusing ADM1jl\r\n\r\nu0 = initialConditions();\r\n\r\nIV = inflowvector_definition();\r\n\r\nsol,tSol = ADM1sol((0.0,50.0),u0,IV, alg = Rosenbrock23()); # solve the system using the Rosenbrock23 algorithm","category":"page"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"In principle, any ODE solver listed in the DifferentialEquations documentation can be used to solve the system. However, ADM1 is a stiff system of equations, so many solvers may not be stable.","category":"page"},{"location":"page2/#Variable-Inflow","page":"Getting started","title":"Variable Inflow","text":"","category":"section"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"To solve the system for variable inflow, specify the inflow as a Vector{Vector{Float}}, ie. as a vector that contains the vector of inflow conditions at a different times, these times are indexed by an additional input vector t.","category":"page"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"The ADM1sol function interpolates the function using the interpolate function from the Interpolations package (documentation for Interpolations available here). The Gridded(Linear()) interpolation algorithm is specified, meaning that the interpolation between timesteps is linear. Interpolation allows for the use of adaptive step methods, which are more stable than fixed stepsize methods. As when the inflow is fixed, the default solver algorithm is Rodas4P.","category":"page"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"The following code breaks the timespan into 0.1 day increments and then randomizes the inflow concentrations within 50 percent of the default values every 0.1 days. The system is then solved for these randomly varied inflow vectors.","category":"page"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"using ADM1jl\r\n\r\nu0 = initialConditions(); # the default initial conditions\r\n\r\ntspan = (0.0,50.0); # The timespan of the solution is 50 days\r\n\r\nt = [i for i in tspan[1]:0.1:tspan[2]]; # Break the timespan into 0.1 day increments\r\n\r\nIV_temp = inflowvector_definition(); # temporary inflow vector\r\n\r\nIV = [IV_temp*(0.5*rand()+1.0) for i in 1:length(t)] # for each time in t, vary the inflow concentrations within 50 percent of their default values\r\n\r\nsol,tSol = ADM1sol((0.0,50.0),u0,IV,t); # solve the system\r\n\r\nsol # The solution\r\n\r\ntSol # the time it took to solve\r\n","category":"page"},{"location":"page2/#Multiple-Reactors-in-Parallel","page":"Getting started","title":"Multiple Reactors in Parallel","text":"","category":"section"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"To model multiple reactors in series, (ie. where the outflow from the first reactor becomes to inflow to the second, and so on) make sure that there are model_parameters.csv files corresponding to each reactor in your working directory. These files should be called model_parameters.csv, model_parameters2.csv, model_parameters3.csv, and so on.","category":"page"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"To solve multiple reactors, use the MultiChamberSolution function, which takes the timespan, initial conditions for each reactor, the inflow vector, and the number of reactors as input. The timespan is specified the same as in ADM1sol, the initial conditions are specified as a Tuple of vectors where each vector is the initial conditions for one of the reactors, and the inflow vector is specified the same as in ADM1sol. MultiChamberSolution returns the solutions to reactors as a Tuple, where the first element of the Tuple is the solution to reactor 1, the second is the solution to reactor 2, and so on.","category":"page"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"The following code models three reactors in series. Each of the reactors has the same initial conditions.","category":"page"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"using ADM1jl\r\n\r\nu0 = initialConditions(); # default initial conditions\r\n\r\nIV = inflowvector_definition(); # default inflow vector\r\n\r\nsols = MultiChamberSolution((0.0,200.0),(u0,u0,u0),IV,3); # solve the three reactors\r\n\r\nsols[1] # solution to first reactor\r\n\r\nsols[2] # solution to second reactor\r\n\r\nsols[3] # solution to third reactor","category":"page"},{"location":"page2/#Variable-Inflow-2","page":"Getting started","title":"Variable Inflow","text":"","category":"section"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"To specify variable inflow to the first reactor in the series, the input is much the same as in the ADM1sol case:","category":"page"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"using ADM1jl\r\n\r\nu0 = initialConditions();\r\n\r\nt = [i for i in 0.0:0.1:50.0];\r\n\r\nIV_temp = inflowvector_definition();\r\n\r\nIV = [IV_temp*(0.5*rand()+1.0) for i in 1:length(t)];\r\n\r\nsols = MultiChamberSolution((0.0,50.0),(u0,u0,u0),IV,t,3);","category":"page"},{"location":"page2/#Plotting","page":"Getting started","title":"Plotting","text":"","category":"section"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"ADM1jl has a built-in plotting function, plotSols, that uses Julia's Plots package to plot the solutions. The following code demonstrates how it functions: ","category":"page"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"using ADM1jl\r\n\r\nu0 = initialConditions(); # assigns the default initial conditions to u0\r\n\r\nIV = inflowvector_definition(); # assigns the default inflow vector to IV\r\n\r\ntspan = (0.0,200.0); # the solution will be computed from t=0.0 to t=200.0\r\n\r\nsol, tSol = ADM1sol(tspan,u0,IV); # compute the solution\r\n\r\nplotSols(sol) # displays the plots","category":"page"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"However, there is an error in the Plots package that may cause the plots to overwrite eachother so that only the second plot is displayed. To work around this the following keyword arguments can be used:","category":"page"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"using ADM1jl\r\n\r\nu0 = initialConditions();\r\n\r\nIV = inflowvector_definition();\r\n\r\nsol, tSol = ADM1sol((0.0,200.0),u0,IV); # compute the solution\r\n\r\nplt1,plt2 = plotSols(sol,displayPlots=false,returnPlots=true); # stop the plots from displaying automatically and return the plots objects instead\r\n\r\ndisplay(plt1) # display the first plot manually\r\n\r\ndisplay(plt2) # display the second plot manually","category":"page"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"To change the title of the plots use the titleText keyword argument. To save the plots as .png files, use the savePNG boolean keyword argument. The files will have the same name as the plots titles. For example, the following code titles the plots \"Sample Plots\" and saves them as Sample Plots (1 of 2).png and Sample Plots (2 of 2).png.","category":"page"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"using ADM1jl\r\n\r\nu0 = initialConditions();\r\n\r\nIV = inflowvector_definition();\r\n\r\nsol, tSol = ADM1sol((0.0,200.0),u0,IV); # compute the solution\r\n\r\nplotSols(sol,titleText=\"Sample Plots\",displayPlots=false,savePNG=true); # title the plots \"Sample Plots\" and save them to .png files","category":"page"},{"location":"page2/#State-Variables-and-their-Indices","page":"Getting started","title":"State Variables and their Indices","text":"","category":"section"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"The follow table shows which state variable corresponds to each index.","category":"page"},{"location":"page2/","page":"Getting started","title":"Getting started","text":"Index State Variable\n1 S_su\n2 S_aa\n3 S_fa\n4 S_va\n5 S_bu\n6 S_pr\n7 S_ac\n8 S_h2\n9 S_ch4\n10 S_IC\n11 S_IN\n12 S_I\n13 X_xc\n14 X_ch\n15 X_pr\n16 X_li\n17 X_su\n18 X_aa\n19 X_fa\n20 X_c4\n21 X_pro\n22 X_ac\n23 X_h2\n24 X_I\n25 S_va_ion\n26 S_bu_ion\n27 S_pro_ion\n28 S_ac_ion\n29 S_hco3_ion\n30 S_nh3\n31 S_cat\n32 S_an\n33 S_gas_h2\n34 S_gas_ch4\n35 S_gas_co2","category":"page"}]
}
